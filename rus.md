# "Двуликость" вашего сайта

Совсем как у римского бога [Януса][1] (а также у большинства политиков), у каждого
веб-приложения два "лица": его "человеческая" сторона, созданная для взаимодействия
с людьми, и техническая сторона, предназначенная для работы с компьютерными системами,
часто вследствии манипуляций человека. Если одна из этих составляющих использовуется
аудиторией для которой она не предназначена, возникает вероятность сбоев.

Когда в пользовательском интерфейсе, предназначеном для использования человеком,
слишком явно используется дизайн и язык созданные для использования системой, людям
трудно с ним взаимодействовать. В то же время, если информация не структурирована
должным образом, она становится непригодной для "машинной" обработки - следовательно
и системные требования игнорировать нельзя.

Люди и машины воспринимают информацию по-разному. Мы должны установить баланс между
удовлетворением потребностей и тех, и других.

## Ознакомление с Принципом Устойчивости

В 1980 году программист Джон Постел опубликовал [первую спецификацию][2] для протокола
управления передачей данных (Transmission Control Protocol), который остается главным
средством передачи данных в Интернете. В своей спецификации Джон сформулировал принцип
устойчивости:
> Будь требователен к тому, что отсылаешь, и либерален к тому, что принимаешь.

Это золотое правило обработки данных часто применяется для технических протоколов
низшего уровня вроде TCP, а также находит широкое применение в области пользовательских
интерфейсов.

Чтобы удовлетворять потребности пользователя, приложения должны обладать качествами,
которые упрощают взаимодействие с ними для человека: чувствительность, гибкость и
толерантность к любому количеству действий совершаемых пользователем. В то же время,
для того, чтобы система была действительно устойчивой, ее технической части необходимо
проделывать огромную работу с получаемой информацией: все данные вводимые пользователем
должны восприниматься как [вредоносные по умолчанию][3] и проходить валидацию перед тем,
как быть переданными следующей системе.

Создание системы, которая будет учитывать абсолютно разные требования исходящие от
человека и машины, непростая задача. Когда речь идет о программировании высокого уровня,
можно утверждать что *вебприложение является устойчивым* если оно:

1. Позволяет пользователю вводить данные в разных формах, выделяет потребностям и
предпочтениям человека более высокий приоритет, чем требованиям машины;
2. Проводит интерпретацию данных предоставленых пользователем, в соответствии с
требованиями компьютерных систем;
3. Определяет какие вводимые данные являются приемлемыми в конкретной ситуации;
4. Обеспечивает обратную связь с пользователем в понятной для него форме, особенно
когда введённые данные не поддаются обработке.

У человека и компьютера в большинстве случаев будет отличаться понимание того, как
должны выглядеть данные вводимые пользователем, независимо от того, идет ли речь о
заполнении простейшей формы или сложной программе. Наш мозг состоит не из силликона.
Однако, пропасть между пользователем и машиной в большинстве случаев преодолеть можно,
если взять на вооружение принцип устойчивости.

## Числа

Человек не видит особой разницы между "один", "1" и "1.00". Однако, для компьютера
они очень сильно отличаются. В большинстве языков програмирования они отосятся к
разным [типам][4] данных с уникальными характеристиками. Попытка произвести математические
рассчеты с неподходящим для этого типом данных приведет к непредсказуемым результатам.
Таким образом, если для работы приложения нужно, чтобы пользователь ввел число, его
разработчики должны позаботиться о том, чтобы формат вводимой информации соответствовал
требованиям системы. Пользователи обычно не обращают внимание на такие нюансы, но они
подстерегают нас на каждом шагу.

Покупая что-нибудь по телефону, вы никогда не услышите от оператора просьбу назвать номер
вашей кредитки, используя только цифры, без пробелов или чёрточек. Его не введут в смятение
паузы или заминки в вашей речи. Он без труда различает цифры на слух. Однако подобные
подсказки о том, как пользователю следует вводить данные, чтобы они соответствовали
требованиям компьютера, встречаются в веб-формах сплошь и рядом. А не лучше ли бы было,
если компьютер мог бы воспринимать данные в соответствии с предпочтениями пользователя?

Во многих случаях - это возможно, если мы используем принцип устойчивости, чтобы
помочь нашему приложению принимать от пользователя данные в любой форме и конвертировать
их в формат, который понимает система.

Можно, например, воплотить это на стадии взаимодействия с интерфейсом, настроив поля
формы таким образом, чтобы они проводили начальную обработку данных с незамедлительным
выведением обратной информации о том, что происходит. Рассмотрим поле, в которое
необходимо ввести число и денежную единицу:

![Form input requesting a currency value](img/01-currency-input_ru.png?raw=true&repo=Your Website has Two Faces "Form input requesting a currency value")

[В HTML 5 введены][5] новые атрибуты для элемента `input`, среди них `type` для `number`
и атрибут `pattern`, с помощью которых разработчик может указать необходимый формат
вводимой информации. К сожалению, поддержка этих атрибутов браузерами пока [неполная][6]
и нестабильная. Однако, то же самое можно воплотить и с помощью JavaScript. Например:

	<input onkeyup="value=value.replace(/[^0-9\.]/g,'')" />
	<input onblur="if(value.match(/[^0-9\.]/)) raise_alert(this)" />

Код первой строки блокирует введение данных, которые не являются цифрами или точкой в
десятичном числе. Вторая строка выводит уведомление.

Этот простой пример можно значительно [усложнить][7] и следовательно улучшить,
но такие приемы всё равно вынуждают пользователя подчиняться правилам, которые
устанавливает компьютер. В качестве альтернативы, можно предоставить пользователю
возможность вводить данные в том формате, который он считает нужным, и затем,
используя регулярные выражения, перевести их в десятичные значения на сервере.
Согласно директиве №3, приложение проведет проверку на работоспособность и выдаст
ошибку, если данные предоставленные пользователем являются невразумительными или
выходят за рамки понимания системы.

Либеральная "человеческая" составляющая нашего приложения сделает предположение,
что такая ситуация является исключением, ведь если интерфейс хорошо спроектирован,
и все поля как следует подписаны, большинство людей введут данные в подходящем виде.
Хотя точное значение вводимых данных может отличаться ("$10.00" или "10"), компьютер
может без проблем обработать такие данные и перевести их в десятичное значение, при
вводе или на сервере. Однако его осторожная "техническая часть", ориентированная на
взаимодействие с машиной, проверит это предположение перед тем, как предпринимать
какое-либо действие. Если имеет место важная транзакция, например, когда пользователь
вводит сумму пожертвования, система должна продемонстрировать правильное понимание
введенных данных и выдать запрос на подтверждение перед тем, как продолжить их обработку,
даже если они не выходят за рамки понимания системы. Иначе грубая конвертация текстового
значения в числовое может привести к неожиданному, и даже потенциально нежелательному для пользователя, результату:

![Overly aggressive reduction of text input to a number leads to unexpected results](img/02-donation_ru.png?raw=true&repo=Your Website has Two Faces "Overly aggressive reduction of text input to a number leads to unexpected results")

## Даты

С точки зрения компьютера, дата и время - всего лишь особенный вид числовых данных. В
системах на базе UNIX, например, время часто обозначается количеством [секунд прошедших][8]
с 1 Января 1970 года.

Для человека, однако, контекст играет большую роль в понимании даты. Когда Алиса
спрашивает: "Встретимся в четверг?", Боб может спокойно предположить, что она имеет
ввиду следующий четверг и у него нет необходимости это уточнять. Разработчикам интерфейсов
стоит сделать всё возможное, чтобы максимально приблизиться к человеческому методу
интерпретации дат в зависимости от контекста.

Это можно сделать, если вспомнить типичные методы запроса даты у пользователя:

* текстовый ввод, часто указываются требования к формату (например,
*мм/дд/гггг*);
* виджет мини-календарь с датами, упорядоченными по месяцам.

Использование одного из этих методов не исключает возможность использования
другого, в устойчивом приложении может быть предложен один из них или оба метода
одновременно, в зависимости от обстоятельств.

В некоторых случаях виджет-календарь может быть очень удобным, например, когда нужно
определить неизвестную дату в будущем (к примеру, второй вторник следующего февраля).
Чаще всего текстовый ввод является самым быстрым способом указать известную дату,
особенно дату в недалеком будущем. Если Боб хочет сделать пометку о встрече в четверг,
ему удобнее набрать на клавиатуре слово "четверг" или сокращенно "четв", нежели открывать
календарь и курсором (или, что еще хуже, пальцем) тыкать по маленькой ячейке с нужной
датой.

Хочу отметить, что устанавливая слишком жесткие требования к формату, в котором
вводится дата, мы сводим на нет преимущество текстового ввода - если Боб должен
определиться с точной датой в числовом формате и ввести ее в определенном виде,
ему все же может потребоваться календарь. Или, например, приложение запрашивает
дату рождения Алисы в формате *мм/дд/гггг*, и выдает ошибку когда она вводит 1/1/1970,
пропуская ноль в месяце и дате, что вызывает недоумение. Ведь человеку оба варианта
написания даты кажутся одинаково понятными.

Приложение, построеное с учетом принципа стабильности, принимает от пользователя
любые данные, если они напоминают дату, опять-таки, *запрашивая* подтверждение того,
что система их интерпретировала правильно. Уведомление об *ошибке* выводится только в
том случае, если интерпретация данных прошла неудачно или же они выходят за рамки
понимания системы. Существует [несколько][9] [программных][10] [библиотек][11], которые
помогают компьютерам переводить человеческие описания дат, вроде "завтра", "в следующую
пятницу" или "Апрель, 11" в структурированные еквиваленты, поддерживаемые машинами. Хотя
многие из библиотек достаточно сложные, все же у них есть ограничения. Поэтому, используя
их, стоит предоставить пользователю примеры форматов правильного введения данных, даже
если система принимает и другие варианты.

## Адреса

Наверное из всех типов данных, поля для ввода адреса намного больше зависят от
строения базы данных, чем от заботы об удобстве пользователей. Взгляните на этот
распостраненный шаблон:

![Typical set of inputs for capturing an address](img/03-address_ru.png?raw=true&repo=Your Website has Two Faces "Typical set of inputs for capturing an address")

Такой набор полей подходит для большинства адресов в США, но далеко не для всех адресов
[других стран мира][12]. И даже в США, для некоторых официальных адресов, такой набор
полей не будет достаточным.

Разработчик, который стремится создать приложение с действительно либеральным восприятием
вводимых данных, мог бы дерзнуть предложить для ввода адреса одно поле `textarea`, в
которое пользователь может ввести адрес в произвольной форме, как если бы он писал его
на почтовом конверте. И если адрес будет использоваться только целиком, вполне достаточно
будет сохранить его в виде цельного текстового блока. Разработчику стоит задать себе
вопрос: действительно ли для дальнейшего использования информации нужно разбивать ее
на отдельные части?

Довольно часто по коммерческим причинам возникает потребность в хранении информации
по частям. Существует множество локальных и онлайн-сервисов, которые позволяют
стандартизировать данные, введенные в разных форматах, вне зависимости от того, были
ли они собраны с помощью одного текстового поля или нескольких структурированных
элементов.

Рассмотрим следующий адрес:

*Avenue Appia 20*

*1211 Genève 27*

*СЮЗИ*

[API геокодирования Google][13], например, может преобразовать его в нечто подобное
следующему, с высокой детализацией для картографических приложений:

    "address_components" : [
      {
         "long_name" : "20",
         "short_name" : "20",
         "types" : [ "street_number" ]
      },
      {
         "long_name" : "Avenue Appia",
         "short_name" : "Avenue Appia",
         "types" : [ "route" ]
      },
      {
         "long_name" : "Geneva",
         "short_name" : "Geneva",
         "types" : [ "locality", "political" ]
      },
      {
         "long_name" : "Genève",
         "short_name" : "Genève",
         "types" : [ "administrative_area_level_2", "political" ]
      },
      {
         "long_name" : "Geneva",
         "short_name" : "GE",
         "types" : [ "administrative_area_level_1", "political" ]
      },
      {
         "long_name" : "Switzerland",
         "short_name" : "CH",
         "types" : [ "country", "political" ]
      },
      {
         "long_name" : "1202",
         "short_name" : "1202",
         "types" : [ "postal_code" ]
      }
    ]

Компоненты (и условия лицензии) таких систем стандартизации различаются и могут подходить
не для всех приложений. Длинные адреса могут стать проблемой и для них нужно придумать
алтернативный способ интерпретации приложениями. Это требует дополнительных усилий. Однако,
чтобы обеспечить максимальный комфорт для пользователя, приложение должно все же попробовать
интерпретировать данные. Ведь пользователей не особенно заботит то, что номер их дома и
названия улицы должны быть введены в базу данных отдельно, чтобы их можно было использовать
в дальнейшем.

## Исключение или правило?

Преобразование человеческого языка в структурированные данные - не всегда проходит успешно.
Согласно директиве №4, устойчивая система должна быть способна определить пограничный случай
и справиться с ним, сохраняя изящность и [почтительность][14] к пользователю, в то же время
минимизируя возможность его повторения. Как в поговорке: хвост не должен вилять собакой. Так
и в плане взаимодействия системы с пользователем: если возможно создание интерфейса, который
будет работать без сбоев в 95% случаев, сократит время, затрачиваемое на выполнение заданий,
и будет полностью соответствовать ожиданиям пользователя по чувствительности к его требованиям,
тогда наверняка результат стоит усилий потраченых на создание дополнительного цикла обратной
связи для обработки остальных пяти процентов.

Вспомните еще раз пример с размещением заказа по телефону при общении с человеком. Если он
не понимает того, что вы говорите, он может попросить уточнить. Даже когда он что-то не
вполне понял, он может прочитать вам записанную им информацию и попросить подтверить все
ли правильно. Такое взаимодействие считается нормальным и не выходящим за рамки вежливости.
Собственно, оно служит подтверждением тому, что результат этого взаимодействия будет соответствовать ожидаемому результату.

Кроме того, малоивероятно, что сразу же после ответа на звонок оператор предоставит
вам набор четких инструкций по взаимодействию с ним и, когда вы не выполните одну из
инструкций, начнет вас за это [бранить][15]. Веб-приложения действуют именно так,
постоянно (иногда даже пропуская этап предоставления инструкций и переходя сразу же
к порицанию).

Для большинства разработчиков целостность системы является приоритетной задачей по
понятным причинам. Чем лучше продумана структура введения данных пользователем, тем
надежнее она ведет себя при дальнейшей обработке. Мы стремимся к созданию надежных
систем, потому рьяно защищаем потребности машины. Когда введенные данные не проходят
валидацию, мы виним в этом пользователя, считая что он допустил ошибку, попытку ввести
неправильные данные в тщательно спроектированное *нами* приложение.

Вне зависимости от того, входит ли в наши [служебные обязанности][16] обеспечение
удобства для пользователя, мы должны уделять потребностям людей, которые будут
пользоваться нашим приложением, по крайней мере столько же внимания, сколько мы уделяем
потребностям компьютерных систем. Неважно для решения какой проблемы было создано
приложение, в первую очередь оно создано для того, чтобы принести пользу человеку.
Работа каждого, кто участвует в создании приложения, влияет на его удобство для
пользователя, поэтому его улучшение - задача общая. Учитывая принцип устойчивости,
мы можем достигнуть баланса между удовлетворением нужд человека и компьютера.

Неизменное влияние закона Постела на Интернет, в течении трёх десятилетий, доказывает
его значимость. Пусть же всё програмное обеспечение созданное нами и впечатление
пользователей от работы с ним, соответствует высоким стандартам этого закона.

[1]: http://en.wikipedia.org/wiki/Janus
[2]: http://tools.ietf.org/html/rfc761
[3]: https://www.owasp.org/index.php/Data_Validation#Sanitize_with_Whitelist
[4]: http://en.wikipedia.org/wiki/Data_type
[5]: http://alistapart.com/article/forward-thinking-form-validation
[6]: http://www.quirksmode.org/html5/inputs.html
[7]: www.alistapart.com/articles/inline-validation-in-web-forms/
[8]: http://www.epochconverter.com/
[9]: http://lee.jarvis.co/chronic/
[10]: http://php.net/manual/en/function.strtotime.php
[11]: http://natty.joestelmach.com/
[12]: http://www.columbia.edu/~fdc/postal/
[13]: https://developers.google.com/maps/documentation/geocoding/
[14]: http://alistapart.com/article/good-help-is-hard-to-find
[15]: http://en.wikipedia.org/wiki/The_Soup_Nazi
[16]: http://archive.aneventapart.com/alasurvey2011/00.html#jt
